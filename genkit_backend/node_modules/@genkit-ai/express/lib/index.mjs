import bodyParser from "body-parser";
import cors from "cors";
import express from "express";
import {
  runWithStreamingCallback
} from "genkit";
import {
  getCallableJSON,
  getHttpStatus
} from "genkit/context";
import { logger } from "genkit/logging";
const streamDelimiter = "\n\n";
function expressHandler(action, opts) {
  return async (request, response) => {
    const { stream } = request.query;
    if (!request.body) {
      const errMsg = `Error: request.body is undefined. Possible reasons: missing 'content-type: application/json' in request headers or misconfigured JSON middleware ('app.use(express.json()')? `;
      logger.error(errMsg);
      response.status(400).json({ message: errMsg, status: "INVALID ARGUMENT" }).end();
      return;
    }
    let input = request.body.data;
    let context;
    try {
      context = await opts?.contextProvider?.({
        method: request.method,
        headers: Object.fromEntries(
          Object.entries(request.headers).map(([key, value]) => [
            key.toLowerCase(),
            Array.isArray(value) ? value.join(" ") : String(value)
          ])
        ),
        input
      }) || {};
    } catch (e) {
      logger.error(
        `Auth policy failed with error: ${e.message}
${e.stack}`
      );
      response.status(getHttpStatus(e)).json(getCallableJSON(e)).end();
      return;
    }
    if (request.get("Accept") === "text/event-stream" || stream === "true") {
      response.writeHead(200, {
        "Content-Type": "text/plain",
        "Transfer-Encoding": "chunked"
      });
      try {
        const onChunk = (chunk) => {
          response.write(
            "data: " + JSON.stringify({ message: chunk }) + streamDelimiter
          );
        };
        const result = await runWithStreamingCallback(
          action.__registry,
          onChunk,
          () => action.run(input, {
            onChunk,
            context
          })
        );
        response.write(
          "data: " + JSON.stringify({ result: result.result }) + streamDelimiter
        );
        response.end();
      } catch (e) {
        logger.error(
          `Streaming request failed with error: ${e.message}
${e.stack}`
        );
        response.write(
          `error: ${JSON.stringify({ error: getCallableJSON(e) })}${streamDelimiter}`
        );
        response.end();
      }
    } else {
      try {
        const result = await action.run(input, { context });
        response.setHeader("x-genkit-trace-id", result.telemetry.traceId);
        response.setHeader("x-genkit-span-id", result.telemetry.spanId);
        response.status(200).json({
          result: result.result
        }).end();
      } catch (e) {
        logger.error(
          `Non-streaming request failed with error: ${e.message}
${e.stack}`
        );
        response.status(getHttpStatus(e)).json(getCallableJSON(e)).end();
      }
    }
  };
}
function withContextProvider(flow, context) {
  return {
    flow,
    context
  };
}
function startFlowServer(options) {
  const server = new FlowServer(options);
  server.start();
  return server;
}
class FlowServer {
  /** List of all running servers needed to be cleaned up on process exit. */
  static RUNNING_SERVERS = [];
  /** Options for the flow server configured by the developer. */
  options;
  /** Port the server is actually running on. This may differ from `options.port` if the original was occupied. Null is server is not running. */
  port = null;
  /** Express server instance. Null if server is not running. */
  server = null;
  constructor(options) {
    this.options = {
      ...options
    };
  }
  /**
   * Starts the server and adds it to the list of running servers to clean up on exit.
   */
  async start() {
    const server = express();
    server.use(bodyParser.json(this.options.jsonParserOptions));
    server.use(cors(this.options.cors));
    logger.debug("Running flow server with flow paths:");
    const pathPrefix = this.options.pathPrefix ?? "";
    this.options.flows?.forEach((flow) => {
      if ("context" in flow) {
        const flowPath = `/${pathPrefix}${flow.flow.__action.name}`;
        logger.debug(` - ${flowPath}`);
        server.post(
          flowPath,
          expressHandler(flow.flow, { contextProvider: flow.context })
        );
      } else {
        const flowPath = `/${pathPrefix}${flow.__action.name}`;
        logger.debug(` - ${flowPath}`);
        server.post(flowPath, expressHandler(flow));
      }
    });
    this.port = this.options?.port || (process.env.PORT ? parseInt(process.env.PORT) : 0) || 3400;
    this.server = server.listen(this.port, () => {
      logger.debug(`Flow server running on http://localhost:${this.port}`);
      FlowServer.RUNNING_SERVERS.push(this);
    });
  }
  /**
   * Stops the server and removes it from the list of running servers to clean up on exit.
   */
  async stop() {
    if (!this.server) {
      return;
    }
    return new Promise((resolve, reject) => {
      this.server.close((err) => {
        if (err) {
          logger.error(
            `Error shutting down flow server on port ${this.port}: ${err}`
          );
          reject(err);
        }
        const index = FlowServer.RUNNING_SERVERS.indexOf(this);
        if (index > -1) {
          FlowServer.RUNNING_SERVERS.splice(index, 1);
        }
        logger.debug(
          `Flow server on port ${this.port} has successfully shut down.`
        );
        this.port = null;
        this.server = null;
        resolve();
      });
    });
  }
  /**
   * Stops all running servers.
   */
  static async stopAll() {
    return Promise.all(
      FlowServer.RUNNING_SERVERS.map((server) => server.stop())
    );
  }
}
export {
  FlowServer,
  expressHandler,
  startFlowServer,
  withContextProvider
};
//# sourceMappingURL=index.mjs.map