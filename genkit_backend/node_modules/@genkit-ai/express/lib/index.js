"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var src_exports = {};
__export(src_exports, {
  FlowServer: () => FlowServer,
  expressHandler: () => expressHandler,
  startFlowServer: () => startFlowServer,
  withContextProvider: () => withContextProvider
});
module.exports = __toCommonJS(src_exports);
var import_body_parser = __toESM(require("body-parser"));
var import_cors = __toESM(require("cors"));
var import_express = __toESM(require("express"));
var import_genkit = require("genkit");
var import_context = require("genkit/context");
var import_logging = require("genkit/logging");
const streamDelimiter = "\n\n";
function expressHandler(action, opts) {
  return async (request, response) => {
    const { stream } = request.query;
    if (!request.body) {
      const errMsg = `Error: request.body is undefined. Possible reasons: missing 'content-type: application/json' in request headers or misconfigured JSON middleware ('app.use(express.json()')? `;
      import_logging.logger.error(errMsg);
      response.status(400).json({ message: errMsg, status: "INVALID ARGUMENT" }).end();
      return;
    }
    let input = request.body.data;
    let context;
    try {
      context = await opts?.contextProvider?.({
        method: request.method,
        headers: Object.fromEntries(
          Object.entries(request.headers).map(([key, value]) => [
            key.toLowerCase(),
            Array.isArray(value) ? value.join(" ") : String(value)
          ])
        ),
        input
      }) || {};
    } catch (e) {
      import_logging.logger.error(
        `Auth policy failed with error: ${e.message}
${e.stack}`
      );
      response.status((0, import_context.getHttpStatus)(e)).json((0, import_context.getCallableJSON)(e)).end();
      return;
    }
    if (request.get("Accept") === "text/event-stream" || stream === "true") {
      response.writeHead(200, {
        "Content-Type": "text/plain",
        "Transfer-Encoding": "chunked"
      });
      try {
        const onChunk = (chunk) => {
          response.write(
            "data: " + JSON.stringify({ message: chunk }) + streamDelimiter
          );
        };
        const result = await (0, import_genkit.runWithStreamingCallback)(
          action.__registry,
          onChunk,
          () => action.run(input, {
            onChunk,
            context
          })
        );
        response.write(
          "data: " + JSON.stringify({ result: result.result }) + streamDelimiter
        );
        response.end();
      } catch (e) {
        import_logging.logger.error(
          `Streaming request failed with error: ${e.message}
${e.stack}`
        );
        response.write(
          `error: ${JSON.stringify({ error: (0, import_context.getCallableJSON)(e) })}${streamDelimiter}`
        );
        response.end();
      }
    } else {
      try {
        const result = await action.run(input, { context });
        response.setHeader("x-genkit-trace-id", result.telemetry.traceId);
        response.setHeader("x-genkit-span-id", result.telemetry.spanId);
        response.status(200).json({
          result: result.result
        }).end();
      } catch (e) {
        import_logging.logger.error(
          `Non-streaming request failed with error: ${e.message}
${e.stack}`
        );
        response.status((0, import_context.getHttpStatus)(e)).json((0, import_context.getCallableJSON)(e)).end();
      }
    }
  };
}
function withContextProvider(flow, context) {
  return {
    flow,
    context
  };
}
function startFlowServer(options) {
  const server = new FlowServer(options);
  server.start();
  return server;
}
class FlowServer {
  /** List of all running servers needed to be cleaned up on process exit. */
  static RUNNING_SERVERS = [];
  /** Options for the flow server configured by the developer. */
  options;
  /** Port the server is actually running on. This may differ from `options.port` if the original was occupied. Null is server is not running. */
  port = null;
  /** Express server instance. Null if server is not running. */
  server = null;
  constructor(options) {
    this.options = {
      ...options
    };
  }
  /**
   * Starts the server and adds it to the list of running servers to clean up on exit.
   */
  async start() {
    const server = (0, import_express.default)();
    server.use(import_body_parser.default.json(this.options.jsonParserOptions));
    server.use((0, import_cors.default)(this.options.cors));
    import_logging.logger.debug("Running flow server with flow paths:");
    const pathPrefix = this.options.pathPrefix ?? "";
    this.options.flows?.forEach((flow) => {
      if ("context" in flow) {
        const flowPath = `/${pathPrefix}${flow.flow.__action.name}`;
        import_logging.logger.debug(` - ${flowPath}`);
        server.post(
          flowPath,
          expressHandler(flow.flow, { contextProvider: flow.context })
        );
      } else {
        const flowPath = `/${pathPrefix}${flow.__action.name}`;
        import_logging.logger.debug(` - ${flowPath}`);
        server.post(flowPath, expressHandler(flow));
      }
    });
    this.port = this.options?.port || (process.env.PORT ? parseInt(process.env.PORT) : 0) || 3400;
    this.server = server.listen(this.port, () => {
      import_logging.logger.debug(`Flow server running on http://localhost:${this.port}`);
      FlowServer.RUNNING_SERVERS.push(this);
    });
  }
  /**
   * Stops the server and removes it from the list of running servers to clean up on exit.
   */
  async stop() {
    if (!this.server) {
      return;
    }
    return new Promise((resolve, reject) => {
      this.server.close((err) => {
        if (err) {
          import_logging.logger.error(
            `Error shutting down flow server on port ${this.port}: ${err}`
          );
          reject(err);
        }
        const index = FlowServer.RUNNING_SERVERS.indexOf(this);
        if (index > -1) {
          FlowServer.RUNNING_SERVERS.splice(index, 1);
        }
        import_logging.logger.debug(
          `Flow server on port ${this.port} has successfully shut down.`
        );
        this.port = null;
        this.server = null;
        resolve();
      });
    });
  }
  /**
   * Stops all running servers.
   */
  static async stopAll() {
    return Promise.all(
      FlowServer.RUNNING_SERVERS.map((server) => server.stop())
    );
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FlowServer,
  expressHandler,
  startFlowServer,
  withContextProvider
});
//# sourceMappingURL=index.js.map